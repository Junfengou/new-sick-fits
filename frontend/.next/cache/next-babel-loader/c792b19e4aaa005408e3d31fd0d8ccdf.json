{"ast":null,"code":"/*\r\n    The whole purpose of this file is to solve the ordering issue with pagination when user delete an item\r\n\r\n    Each page displays 4 items. When an item gets deleted, it is ideal to push the next item on the next page to the previous page\r\n        to fill in the spot. Since initially all items in apollo cache are categorized in different sections by pagination, \r\n        we need a way to combine all of them in a single list in order to filter out the items we need. \r\n\r\n    This is from video : #35\r\n    Example: \r\n        1 2 3 4 | 5 6 7 8 | 9 10 11 12\r\n            This is the initial item list, each number represent a single item. Each line represent a page \r\n        1 2 3 4 | 5 6 7 9 | 10 11 12 \r\n            When item [#8] gets deleted, we need to move item [#9] up a page to maintain the consistency of 4 items per page\r\n\r\n*/\nimport React from \"react\";\nimport { PAGINATION_QUERY } from \"../components/Pagination\";\n\nfunction paginationField() {\n  return {\n    keyArgs: false,\n\n    // Tells Apollo that I will take care everything\n    // skip: skip however many items\n    // first: give me the first however many items\n    // args: The skip value that's passed in    cache: Apollo cache\n    read(existing = [], {\n      args,\n      cache\n    }) {\n      var _data$_allProductsMet;\n\n      // console.log({ existing, args, cache });\n      const {\n        skip,\n        first\n      } = args; //Read the number of items on the page from the cache\n\n      const data = cache.readQuery({\n        query: PAGINATION_QUERY\n      });\n      const count = data === null || data === void 0 ? void 0 : (_data$_allProductsMet = data._allProductsMeta) === null || _data$_allProductsMet === void 0 ? void 0 : _data$_allProductsMet.count; // what page we're currently on\n\n      const page = skip / first + 1;\n      const pages = Math.ceil(count / first); // Check if we have existing items, start at skip value and go until you hit (skip + 4)\n\n      const items = existing.slice(skip, skip + first).filter(item => item); //If there are items && if there are enough items to satisfy how many are requested && we are on the last page\n\n      if (items.length && items.length !== first && page === pages) {\n        return items;\n      }\n\n      if (items.length !== first) {\n        // We don't have any items, we must go to the network to fetch them\n        return false;\n      } // If there are items, just return the items from the cache\n\n\n      if (items.length) {\n        console.log(`There are ${items.length} items in the cache! Gonna send them to apollo`);\n        return items;\n      }\n\n      return false; // fallback to network\n      // When Apollo tries to query for all Products, it will first ask the read function for those items\n      // Either do 1 of 2 things:\n      // 1. Return the items because they are already in the cache\n      // OR\n      // 2. Return false from here [create a network request]\n    },\n\n    merge(existing, incoming, {\n      args\n    }) {\n      const {\n        skip,\n        first\n      } = args; // This runs when the Apollo client comes back from the Keystone with the products\n\n      console.log(`Merging items from the network ${incoming.length}`); // If there are existing items in the cache already, we want to take a copy of all the items\n\n      const merged = existing ? existing.slice(0) : [];\n\n      for (let i = skip; i < skip + incoming.length; ++i) {\n        merged[i] = incoming[i - skip];\n      }\n\n      console.log(merged);\n      return merged;\n    }\n\n  };\n}\n\nexport default paginationField;","map":{"version":3,"sources":["D:/React/Advanced-React/Advanced-React/sick-fits/frontend/lib/paginationField.js"],"names":["React","PAGINATION_QUERY","paginationField","keyArgs","read","existing","args","cache","skip","first","data","readQuery","query","count","_allProductsMeta","page","pages","Math","ceil","items","slice","filter","item","length","console","log","merge","incoming","merged","i"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,gBAAT,QAAiC,0BAAjC;;AAEA,SAASC,eAAT,GAA2B;AAC1B,SAAO;AACNC,IAAAA,OAAO,EAAE,KADH;;AACU;AAEhB;AACA;AAEA;AACAC,IAAAA,IAAI,CAACC,QAAQ,GAAG,EAAZ,EAAgB;AAAEC,MAAAA,IAAF;AAAQC,MAAAA;AAAR,KAAhB,EAAiC;AAAA;;AACpC;AACA,YAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAkBH,IAAxB,CAFoC,CAIpC;;AACA,YAAMI,IAAI,GAAGH,KAAK,CAACI,SAAN,CAAgB;AAAEC,QAAAA,KAAK,EAAEX;AAAT,OAAhB,CAAb;AACA,YAAMY,KAAK,GAAGH,IAAH,aAAGA,IAAH,gDAAGA,IAAI,CAAEI,gBAAT,0DAAG,sBAAwBD,KAAtC,CANoC,CAQpC;;AACA,YAAME,IAAI,GAAGP,IAAI,GAAGC,KAAP,GAAe,CAA5B;AACA,YAAMO,KAAK,GAAGC,IAAI,CAACC,IAAL,CAAUL,KAAK,GAAGJ,KAAlB,CAAd,CAVoC,CAYpC;;AACA,YAAMU,KAAK,GAAGd,QAAQ,CAACe,KAAT,CAAeZ,IAAf,EAAqBA,IAAI,GAAGC,KAA5B,EAAmCY,MAAnC,CAA2CC,IAAD,IAAUA,IAApD,CAAd,CAboC,CAepC;;AACA,UAAIH,KAAK,CAACI,MAAN,IAAgBJ,KAAK,CAACI,MAAN,KAAiBd,KAAjC,IAA0CM,IAAI,KAAKC,KAAvD,EAA8D;AAC7D,eAAOG,KAAP;AACA;;AAED,UAAIA,KAAK,CAACI,MAAN,KAAiBd,KAArB,EAA4B;AAC3B;AACA,eAAO,KAAP;AACA,OAvBmC,CAyBpC;;;AACA,UAAIU,KAAK,CAACI,MAAV,EAAkB;AACjBC,QAAAA,OAAO,CAACC,GAAR,CACE,aAAYN,KAAK,CAACI,MAAO,gDAD3B;AAGA,eAAOJ,KAAP;AACA;;AAED,aAAO,KAAP,CAjCoC,CAiCtB;AAEd;AAEA;AAEA;AAEA;AAEA;AACA,KAnDK;;AAoDNO,IAAAA,KAAK,CAACrB,QAAD,EAAWsB,QAAX,EAAqB;AAAErB,MAAAA;AAAF,KAArB,EAA+B;AACnC,YAAM;AAAEE,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAkBH,IAAxB,CADmC,CAEnC;;AACAkB,MAAAA,OAAO,CAACC,GAAR,CAAa,kCAAiCE,QAAQ,CAACJ,MAAO,EAA9D,EAHmC,CAInC;;AACA,YAAMK,MAAM,GAAGvB,QAAQ,GAAGA,QAAQ,CAACe,KAAT,CAAe,CAAf,CAAH,GAAuB,EAA9C;;AACA,WAAK,IAAIS,CAAC,GAAGrB,IAAb,EAAmBqB,CAAC,GAAGrB,IAAI,GAAGmB,QAAQ,CAACJ,MAAvC,EAA+C,EAAEM,CAAjD,EAAoD;AACnDD,QAAAA,MAAM,CAACC,CAAD,CAAN,GAAYF,QAAQ,CAACE,CAAC,GAAGrB,IAAL,CAApB;AACA;;AACDgB,MAAAA,OAAO,CAACC,GAAR,CAAYG,MAAZ;AACA,aAAOA,MAAP;AACA;;AA/DK,GAAP;AAiEA;;AAED,eAAe1B,eAAf","sourcesContent":["/*\r\n    The whole purpose of this file is to solve the ordering issue with pagination when user delete an item\r\n\r\n    Each page displays 4 items. When an item gets deleted, it is ideal to push the next item on the next page to the previous page\r\n        to fill in the spot. Since initially all items in apollo cache are categorized in different sections by pagination, \r\n        we need a way to combine all of them in a single list in order to filter out the items we need. \r\n\r\n    This is from video : #35\r\n    Example: \r\n        1 2 3 4 | 5 6 7 8 | 9 10 11 12\r\n            This is the initial item list, each number represent a single item. Each line represent a page \r\n        1 2 3 4 | 5 6 7 9 | 10 11 12 \r\n            When item [#8] gets deleted, we need to move item [#9] up a page to maintain the consistency of 4 items per page\r\n\r\n*/\r\n\r\nimport React from \"react\";\r\nimport { PAGINATION_QUERY } from \"../components/Pagination\";\r\n\r\nfunction paginationField() {\r\n\treturn {\r\n\t\tkeyArgs: false, // Tells Apollo that I will take care everything\r\n\r\n\t\t// skip: skip however many items\r\n\t\t// first: give me the first however many items\r\n\r\n\t\t// args: The skip value that's passed in    cache: Apollo cache\r\n\t\tread(existing = [], { args, cache }) {\r\n\t\t\t// console.log({ existing, args, cache });\r\n\t\t\tconst { skip, first } = args;\r\n\r\n\t\t\t//Read the number of items on the page from the cache\r\n\t\t\tconst data = cache.readQuery({ query: PAGINATION_QUERY });\r\n\t\t\tconst count = data?._allProductsMeta?.count;\r\n\r\n\t\t\t// what page we're currently on\r\n\t\t\tconst page = skip / first + 1;\r\n\t\t\tconst pages = Math.ceil(count / first);\r\n\r\n\t\t\t// Check if we have existing items, start at skip value and go until you hit (skip + 4)\r\n\t\t\tconst items = existing.slice(skip, skip + first).filter((item) => item);\r\n\r\n\t\t\t//If there are items && if there are enough items to satisfy how many are requested && we are on the last page\r\n\t\t\tif (items.length && items.length !== first && page === pages) {\r\n\t\t\t\treturn items;\r\n\t\t\t}\r\n\r\n\t\t\tif (items.length !== first) {\r\n\t\t\t\t// We don't have any items, we must go to the network to fetch them\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// If there are items, just return the items from the cache\r\n\t\t\tif (items.length) {\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t`There are ${items.length} items in the cache! Gonna send them to apollo`\r\n\t\t\t\t);\r\n\t\t\t\treturn items;\r\n\t\t\t}\r\n\r\n\t\t\treturn false; // fallback to network\r\n\r\n\t\t\t// When Apollo tries to query for all Products, it will first ask the read function for those items\r\n\r\n\t\t\t// Either do 1 of 2 things:\r\n\r\n\t\t\t// 1. Return the items because they are already in the cache\r\n\r\n\t\t\t// OR\r\n\r\n\t\t\t// 2. Return false from here [create a network request]\r\n\t\t},\r\n\t\tmerge(existing, incoming, { args }) {\r\n\t\t\tconst { skip, first } = args;\r\n\t\t\t// This runs when the Apollo client comes back from the Keystone with the products\r\n\t\t\tconsole.log(`Merging items from the network ${incoming.length}`);\r\n\t\t\t// If there are existing items in the cache already, we want to take a copy of all the items\r\n\t\t\tconst merged = existing ? existing.slice(0) : [];\r\n\t\t\tfor (let i = skip; i < skip + incoming.length; ++i) {\r\n\t\t\t\tmerged[i] = incoming[i - skip];\r\n\t\t\t}\r\n\t\t\tconsole.log(merged);\r\n\t\t\treturn merged;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport default paginationField;\r\n"]},"metadata":{},"sourceType":"module"}